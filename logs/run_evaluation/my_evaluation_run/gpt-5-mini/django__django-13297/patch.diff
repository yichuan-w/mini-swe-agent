I will explain what's happening, why it breaks the DB call, and the minimal fixes and recommendations.

Short answer
- The kwargs value is a django.utils.functional.SimpleLazyObject (a lazy wrapper). SQLite's DB parameter binding doesn't accept that wrapper type, so passing it directly to the ORM/DB layer raises "Error binding parameter ... unsupported type".
- Fix: coerce the lazy value to a concrete string before using it in DB queries. Easiest: use str(...) or Django's force_str(...) to force evaluation.

Why this happens
- SimpleLazyObject is used by Django to wrap values that should be evaluated lazily. If some internal change (or some middleware/config) causes the URL/resolver kwargs value to be a SimpleLazyObject in Django 3.1, then when you pass that object directly into the ORM it stays wrapped and SQLite (or other DB backends) cannot bind that wrapper as a parameter.
- Templates and plain string operations often trigger evaluation automatically (so they "work"), but the DB adapter doesn't call str() on parameters â€” it expects native Python types (str, int, etc.). That mismatch causes the error you saw.

Concrete fixes (pick one)
- Quick and clear: coerce to str()
  offer_slug = str(kwargs.get("offer_slug", ""))
- Prefer Django utility for unicode/byte handling: use force_str
  from django.utils.encoding import force_str
  offer_slug = force_str(kwargs.get("offer_slug", ""))
- Defensive: if you want to handle the lazy wrapper explicitly:
  from django.utils.functional import SimpleLazyObject
  v = kwargs.get("offer_slug", "")
  if isinstance(v, SimpleLazyObject):
      v = str(v)
  offer_slug = v

Minimal corrected view example
from django.utils.encoding import force_str
from django.shortcuts import get_object_or_404
from django.views.generic import TemplateView

class OfferView(TemplateView):
    template_name = "offers/offer.html"
    def get_context_data(self, **kwargs):
        offer_slug = force_str(kwargs.get("offer_slug", ""))
        offer = get_object_or_404(Account, slug=offer_slug)
        return {"offer": offer, "offer_slug": offer_slug}

Notes and recommendations
- Using str(...) or force_str(...) is safe and straightforward. force_str is recommended if you want to be explicit about Django's encoding helpers.
- This is a defensive fix in your view. If you can create a minimal reproducible test-case that shows kwargs containing SimpleLazyObject in Django 3.1, consider filing a bug with Django (include the minimal project and exact settings/middleware/URL conf) so maintainers can identify whether an internal change caused the kwargs to be wrapped lazily.
- You can also search your middleware and URL configuration for code that might lazily wrap values (i18n/locale middleware or custom resolvers), but coercing in the view is the least invasive fix.

If you want, I can:
- Help craft a minimal repro to file a Django bug report, or
- Suggest unit tests and a patch to handle this at a higher level (if you prefer a global fix).

No changes detected to generate a patch.